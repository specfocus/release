"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.valuesAreObject = exports.isObject = exports.valuesAreDateString = exports.isDateString = exports.valuesAreDate = exports.isDate = exports.valuesAreArray = exports.isArray = exports.valuesAreEmail = exports.isEmail = exports.valuesAreImageUrl = exports.isImageUrl = exports.valuesAreUrl = exports.isUrl = exports.valuesAreHtml = exports.isHtml = exports.valuesAreString = exports.isString = exports.valuesAreBooleanString = exports.isBooleanString = exports.valuesAreBoolean = exports.isBoolean = exports.valuesAreInteger = exports.isInteger = exports.valuesAreNumeric = exports.isNumeric = void 0;
const date_fns_1 = require("date-fns");
const isNumeric = (value) => !isNaN(parseFloat(value)) && isFinite(value);
exports.isNumeric = isNumeric;
const valuesAreNumeric = (values) => values.every(exports.isNumeric);
exports.valuesAreNumeric = valuesAreNumeric;
const isInteger = (value) => Number.isInteger(value) || !isNaN(parseInt(value));
exports.isInteger = isInteger;
const valuesAreInteger = (values) => values.every(exports.isInteger);
exports.valuesAreInteger = valuesAreInteger;
const isBoolean = (value) => typeof value === 'boolean';
exports.isBoolean = isBoolean;
const valuesAreBoolean = (values) => values.every(exports.isBoolean);
exports.valuesAreBoolean = valuesAreBoolean;
const isBooleanString = (value) => ['true', 'false'].includes(value.toString().toLowerCase());
exports.isBooleanString = isBooleanString;
const valuesAreBooleanString = (values) => values.every(exports.isBooleanString);
exports.valuesAreBooleanString = valuesAreBooleanString;
const isString = (value) => typeof value === 'string';
exports.isString = isString;
const valuesAreString = (values) => values.every(exports.isString);
exports.valuesAreString = valuesAreString;
const HtmlRegexp = /<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i;
const isHtml = (value) => !value || HtmlRegexp.test(value);
exports.isHtml = isHtml;
const valuesAreHtml = (values) => values.every(exports.isHtml);
exports.valuesAreHtml = valuesAreHtml;
const UrlRegexp = /http(s*):\/\/.*/i;
const isUrl = (value) => !value || UrlRegexp.test(value);
exports.isUrl = isUrl;
const valuesAreUrl = (values) => values.every(exports.isUrl);
exports.valuesAreUrl = valuesAreUrl;
const ImageUrlRegexp = /http(s*):\/\/.*\.(jpeg|jpg|jfif|pjpeg|pjp|png|svg|gif|webp|apng|bmp|ico|cur|tif|tiff)/i;
const isImageUrl = (value) => !value || ImageUrlRegexp.test(value);
exports.isImageUrl = isImageUrl;
const valuesAreImageUrl = (values) => values.every(exports.isImageUrl);
exports.valuesAreImageUrl = valuesAreImageUrl;
// This is a very simple regex to find emails
// It it NOT meant to validate emails as the spec is way more complicated but is
// enough for our inference needs
const EmailRegexp = /@{1}/;
const isEmail = (value) => !value || EmailRegexp.test(value);
exports.isEmail = isEmail;
const valuesAreEmail = (values) => values.every(exports.isEmail);
exports.valuesAreEmail = valuesAreEmail;
const isArray = (value) => Array.isArray(value);
exports.isArray = isArray;
const valuesAreArray = (values) => values.every(exports.isArray);
exports.valuesAreArray = valuesAreArray;
const isDate = (value) => !value || value instanceof Date;
exports.isDate = isDate;
const valuesAreDate = (values) => values.every(exports.isDate);
exports.valuesAreDate = valuesAreDate;
// use parse instead of parseISO
const isDateString = (value) => !value || (typeof value === 'string' && (0, date_fns_1.isValid)((0, date_fns_1.parseISO)(value)));
exports.isDateString = isDateString;
const valuesAreDateString = (values) => values.every(exports.isDateString);
exports.valuesAreDateString = valuesAreDateString;
const isObject = (value) => Object.prototype.toString.call(value) === '[object Object]';
exports.isObject = isObject;
const valuesAreObject = (values) => values.every(exports.isObject);
exports.valuesAreObject = valuesAreObject;
